# react fiber

fiber 主要是为了处理大型复杂应用时的性能问题，其主要目标是增量渲染

fiber 出现之前是 stack 架构，通过递归遍历调用栈进行渲染 (虚拟 DOM 的对比，找出差异部分进行渲染更新)，将会递归整个 DOM 树直到完成所有的渲染；
但是由于这种递归调用栈的执行方式是不可中断的，而 javascript 又是单线程，所有任务都在主线程上排队执行
所以当出现 js 执行耗时较久的任务时，比如组件树非常大，或组件渲染耗时很长，长时间占用主线程，导致出现页面的卡顿、白屏这种影响用户体验的情况； 

fiber 架构的出现则解决了这一问题

在 fiber 中放弃采用递归调用栈，改为循环模拟递归，因为循环可以随时中断；
并且利用浏览器空闲时间执行对比任务，解决了渲染过程长期占用主线程的问题
react 将工作分为一个个小单元，在执行完一个单元的时候，查看是否有更高优先级的任务（比如用户输入等交互），如果有则放弃占用主线程，优先执行更高优先级的任务
 

## fiber 的两层含义

1. fiber 是一个执行单元

fiber 之前将整个虚拟 DOM 树的递归对比当作一个任务来处理；
后者则是将整个任务拆分为一个个小单元任务来进行处理，每一个小任务就是一个 fiber 节点的构建


2. fiber 也是一种数据结构，支撑 Fiber 架构的运转

执行完成一个任务之后，通过链表找到下一个任务去执行

本质就是一个 js 对象
```ts
type fiber = {
  // 组件类型、div等标签类型、组件构造函数
  type: any,
  // DOM 对象
  stateNode: any,
  // 指向自己的父级 Fiber 对象
  return: Fiber | null,
  // 指向第一个子级 Fiber 对象
  child: Fiber | null,
  // 指向自己下一个兄弟 Fiber 对象
  sibling: Fiber | null
}
```


## fiber 的工作方式

fiber 的工作分为两个阶段：render 阶段和 commit 阶段

render 阶段：构建 Fiber 对象，构建链表，在链表中标记要执行的 DOM 操作，可中断

commit 阶段：根据构建好的链表进行 DOM 操作，不可中断

```js
        A1
      /    \
    B1      B2
  /    \
C1      C2

```

先从上向下走，构建节点对应的 Fiber 对象
再从下往上走，构建 Fiber 对象及链表

